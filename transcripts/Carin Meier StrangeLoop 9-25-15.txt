   Carin Meier:  "Unconventional Programming with Chemical Computing"
   
   (Live captioning by White Coat Captioning @whitecoatcapxg) 
   >> We're good?
   >> Hello, everybody. Good morning. Thanks for coming to hear about chemical computing. Which is kind of cool and I'm really excited to share that with you. All right. Well, let's get into it, then. So first, this presentation is rated G for general programmers. However, there's a small disclaimer. There will be intense sequences of LISP code.
   [applause]
   >> So you have been warned. So this. Higher order chemical programming style, and I'm not sure if I'm pronouncing these names right but I'll do my best. Also another paper by them is principles of chemical programming.
   >> And also programming self-organizing systems with the higher order chemical language. I will be your narrator. I am Carin Meier. I'm also known on the internet as gigasquid. And I've recently written a book called Living Clojure and I also work at Cognitect. So if you've ever come to any of my talks before, you know that I like to start off with a little story, so this talk is no different. So this starts off with a little story of me cutting my lawn. I live in Cincinnati, Ohio, by a river and it's a little bit rural. I have chickens, and as a result, I have a rather large lawn to mow, so I have a riding lawnmower and I ride around on it and it takes me a few hours to actually get it cut, but I really cherish this time because this is time that I can unplug and be off of the internet and all the other distractions and just think about things. So I usually like to prime myself before I go out to mow the lawn and maybe pick out a programming problem, and on this particular day I had gotten this new cool book called Unconventional Programming Paradigms by Springer. There's a paragraph about chemical programming, so I skimmed over it quickly and I started riding the lawnmower and just thinking about this. So one more thing to let you know about my lawn and my lawnmowing is I usually wear a big hat, because I have, you know, fair skin and I burn easily, so I wear a big hat to cover my head and this works great, except in the case of tree branches. Because when I have this big thing over my head, I sometimes misjudge the distance of going under the tree branch and on this particular day I did misjudge it and I bonked my head and everything went blank, just for a second, but when it came back, like everything was fuzzy with all those little dots, you know, after you've hit your head. And in this moment, you know, brains are funny things. I think I still had a set of neurons thinking about chemical programming and what this means, and I saw these dots at the same time and I saw them all over the grass and I just thought, whoa, the grass is computing.
   [laughter]
   And then I looked at the tree and I was like, whoa, the tree is computing. And then I looked at my hands and the dots and like, I am computing and this is true. You know, the grass is computing. The tree is computing. You are computing. All living things process information with chemical reactions on a molecular level. I mean we do this all the time with our endocrine system, with hormones, our immune system does this, with adaptive defense. Even just small, simple bacteria, they do signal processing of information.
   So we're computing all the time and the world is computing all around us.
   So with this thought all in my mind, I went back in the house and put some ice on my head, but -- so wait, I know you're thinking, you're saying, are we going to be actually programming with chemicals in this talk?
   >> So no. Although that would be super-cool, too. So in this talk we're going be to talking about abstract chemicals. We're going to be actually using the met for metaphor of molecules and reactions to do computing which is really cool in it itself, too. So wait, what am I gonna get out of this talk? Here's the exciting part. You ready?
   >> I don't know.
   [laughter]
   And that's really awesome. Because this talk is -- it's about cross-fertilization. It's about cross fertilization from two very different fields, from computer programming and from nature and biology, and when you take two different fields like this and see what you can learn from them, you get all sorts of research, you get new ideas and this is where innovation comes from, this space.
   And  I will tell you that chemical computing and chemical programming right now is is only in the research domain. I talked to one of the authors in the paper and there's nothing in the wild that he knows of yet, and this is really exciting in itself. Because you all are extremely smart people out there and I'm excited to see when you listen to this what inspire you. So let's talk about the chemical programming. The a the heart of it all is all about the reaction.
   So it's kind of hard to explain without seeing one way versus another way of doing things so that's what we're going to do. We're going to compare two examples. We're going to look at calculating primes, the traditional way that we're all familiar with and then we're going to compute primes with this new prime reaction way of thinking about things. So first let's look at traditional primes -- wait, what is that language with all the parens, some of you are thinking? This is Clojure, and the first most important thing, so how many people are familiar with Clojure? Great, a lot of people are. But for people who are seeing it for the first time, from the hitchhiker's guide to closure, don't worry about the parens. Really. They're OK once you get an editor and it matches the parens and you can move back and forth, so don't panic, the parens are OK. So just a few words about Clojure as a language, it's a wonderful language, I really love it, it's dynamic, so if you're defining a cat, you don't need to say what type it is. It's functional. Here ooh we are we're defining a simple function, say hello, takes a parameter name that simply concatenates a string hello with a same, you invoke that function by putting it in the parens again say hello and then the string molecule will return a hello molecule. It returns on JVM. So it has java interop. You can invoke the methods on them.
   It supports concurrency, which is a wonderful thing, as well. It's immutable data. And it's got bars and refs that I'm not going to go into. There's this exciting thing called ClojureScript now. It has all the same wonderful characteristic of Clojure but it also has JavaScript. Interop.
   All right, so going back to our example, let's go ahead and take a look at computing traditional primes in Clojure. So we would define the function to figure out whether something is prime or not and we'll call it is prime? And we'll give it a number. So we can look at all the factors of this number from 2 up to the number hand we can find its remainedders, and we can see, then, are any of these remainders 0? If they're not, then it's 5. So we can look, is 5'? Yes. Is 6 prime? No.
   We can take a range from 2 up to 100, we can generate all these numbers and then we can map this function, is prime over them and then filter out the ones that are only prime and we're left with a list of primes up to 100. so yay! This is all very comfortable.
   So how do we get to a prime reaction? The first thing you'll notice is I have balls on the screen. And this is to represent molecules so we're going to think of these numbers, these integers as molecules now and they're going to react with each other so if you have a 6 molecule reaction with a 2 molecule, we have a simple rule saying that if it's divisible, you can return a 3 and then the 2. We can see this in code, you can take in a vector, a list of these two molecules. We'll call them A and B, and if A is greater than B, and if the mod of the two together are 0, then we could turn back a vector of this A divided by B and the B. Otherwise we'll just return unchanged the ones that came in. It would not react.
   So we could see the prime reaction of 6 and 2 would return a vector of 3 and 2. And the prime reaction of 5 and 2 would just return unchanged 5 and 2. So then we can take -- can define a whole bunch of these molecules, and we could define another function that is going to mix and react these molecules. So first we shuffle them all up because we don't care what order they're in, and then we're going to partition them in 2s, so go down the list and partition them in 2s and then we're just going to go ahead and make them all react in those pairs and then we're going to flatten out the return vector and that's going to be our result.
   So if we look at the first 10, from doing this mix and react, we can see, well, there definitely may be some primes here, but there's definitely not some primes here, so it's kind of hard to tell exactly. You know, it might be doing some work.
   So maybe we need to do this more times. We need to shuffle them up and mix them up and react them more times. So let's make another function called a reaction cycle and we can do this n times and what it's going to do is exactly that. It's going to go ahead and mix and react and mix and react them for n times so we can do this 100 times and then peek at the first 10 results and we get to see something that looks a lot more like primes resulting. So we can do this even more times. We can do this, what is it, 10,000 times? And we can take a measurement of our result, and our measurement is going to be -- we're going to go ahead and take out all the duplicates and sort them. And lo and behold, we actually get some primes. It may have taken us a little bit more time than otherwise, but we actually came to it from a totally different angle.
   And this way that we did this actually has a name and it's called gamma chemical programming and it's composed of some things that we just did. It's got reaction rules. And they operate on multi-sets of elements. A reaction is composed of two parts. It a condition plus an action, and then you execute these rules and when you execute them, you replace the result elements with the original elements. Now, here is the tricky part: The result is a solution when it reaches steady state, and that's kind of hard to predict. So we don't know exactly how many times we have to mix them. So let's look at another example of not prime. So woo can also calculate the maximum.
   So again, looking at our molecules, we have a 6 molecule and a 2 molecule. And this is going to have the rule of whoever's the biggest molecule we're just going to return that two times. So it's going to return a 6 and a 6.
   Now we get to see a demo. So I've done some simulations of this in ClojureScript and it uses core, a asynch. So each molecule is doing its own thing and let me see if I can make this a little smaller so you can see it and we're going to start it over again. So just a few words that the -- when we're doing in code, this is sort of a visual representation. The point of having them in an XY coordinates is just to help visualization and just to let you know that nothing is happening in a particular order. So we have two molecules a 2 and a 20 and they bump into each other and they become a 2 and a 20. So that's really cool. So let's do more. Let's calculate the max of 100 doing this. All right, this is a little bit more interesting and you'll see the balls actually change colors as they kind of coalesce into groups and you can actually see the -- here's the measurement it's doing distinct and sort down here, so you can see there's groups of 99 are the greens, and there's a few 90s, there's a 63 somewhere around here that's -- I don't know what he's doing.
   But as they react together, they're coalescing into an answer. Let me see, there's an 83. Oh, I see the 83. He's gonna bump into somebody. Why is he not? Oh, all right. And there's one more alone 97. Yes! So we calculated the max with these little balls in a gamma programming example and the answer is 99. So there's other things you can do, too. I'll just show up the primes real quick, because the primes are real cool, too. So the same thing as we were doing before, you can see as they react and get together, they start coalescing down to the answer. They don't have the cool color thing as the max, so I'll -- I won't do it too long, but yeah, when I first came up with this demo, I would spend way too much time looking at it. I would be like wow, look at them all go. So anyway, very much fun:
   Now let's get back to the presentation. Where's my clicker. Oops, there we go.
   So yeah, so the next thing you guys are thinking about, I'm sure, all of you are thinking about is higher order. What if we made the reaction functions molecules, too, right?
   So if we had -- if we look that logic, extracted out of our presentation or out of our program, and we took it out and we actually represented it as a molecule, and reacted those two. What would happen? Like so the function that we were using that we were talking about was primes, that has an area of 2. If that function reacted with a number molecule, it could capture it as argument and because it has an area of 27 if that function with a captured now element ran into another molecule, it would capture it, 2 of them. So this is really cool. So we have a function that has an area 2 it's captured these molecules as it's reacted with them, now what does it do? And this is a cool thing. It actually hatches. And no, I didn't make up this term, it's actually in the paper. So the function molecule hatches out and the result is the original function so it can go run around and interact with more things. And a 3 molecule and a 2 molecule.
   So what does this look like in code? This looks almost exactly like the other code, but it's now embodied in that molecule. So we have the prime reaction that's now taking an area of 2 and an A and B. And if it's a 0, then return A divided by B and otherwise, return the molecules unreacted. The max reaction, it looks even better because it's shorter, but you take in the arity of 2 and then if A is greater than 2, you get As, otherwise A and B.
   If you have a function molecule that happens the max higher order and you capture at a 10 and a 4, then it's going to go ahead and hatch and going to have the original function which is the match function and then two 10s. So another cool thing we've seen is we're always kind of taking in 2 molecules, and then resulting in two molecules and the solution size pretty steady. It doesn't change in size. But we can change that, if we take in less, we call it a reducing function. If A is greater that he B, you could just return A, otherwise you could return. A and B. And this works just type, but one of the problems is -- well, I'll get to that in just a minute. Let's look at the max real quick. So if you have a function and you return a 10 and a 4, then it would just return that function and a 10. So the problem I was going to talk about at least when I'm doing it in this visual presentation, it's really hard because you've got to wait for things to bounce and interact together that it takes a long time and sometimes things don't end up bouncing with each other so I ended up needing some more stirring in my sym lation to get these reacting. So what this means is if you have two function molecules, one that has something captured in it and one doesn't, and if they bump into each other and react, they can just go ahead and exchange their captured values and this just does some more stirring and lets things react a little bit more. so yay! Demo time.
   All right, so let's start of off with a small max example so there's the 20 and the 2. But there's a function molecule, as well. And I think the 20 is going to go over here and maybe bump into the function first and it will be captured and it's going to turn fat. Yes! Okay, and it's going to capture the 2 and it's going to hatch. Oh, it got recaptured and rehatched. But you can see the result are the two 20s. So yeah you're all saying more now, I want to say more.
   [laughter]
   I know. So let's see the max with the function molecules and have them all explode. So when they hatch they kind of explode so I thought that was kind of fun. But you can see as they're going along, they are computing, it takes them a little longer to get to the result than the other one because they have to be captured and do the 2 capture thing and then explode and everything. So it takes a little bit more time, but -P the beauty is that we have function molecules floating around in here and interacting with stuff. We only have one function right now, but maybe we could put two, you know, we could go crazy. And you can see that it's slowly coalescing down to our answer. And I'm only going to up 50 and not 100 because with the function molecules it gets a little bit busy. So reducing primes I'll just let this run for a few seconds so you can see it.
   So you can see, if you let this run a bit that there's less and less molecules on the screen and that's why you would need the little extra stirring.
   But it's all just great fun. OK, back to here.
   My clicker? OK, so what have we seen in these kind of two examples? Well one thing that really emerges is that there's no sequential processing, and that makes it clear, because these molecules are just bumping around into each other at random, so that means that there's really no order in things, and that's interesting, because when you don't have sequential processing, you can really start doing things concurrently and it's important in other areas, too, if you -- than the keynote that was fabulous, you know, that was one of the things, order is kind of hard in certain areas, as well. So a typical problem for concurrency, which chemical programming can handle quite well is something like the dining philosophers problem. So here has heard of the dining philosophers? Oh, great, great, quite a few. So for people who haven't heard the dining philosophers problem so these little circles all around the table are supposed to be philosophers, but I can't draw so you can just imagine these are philosophers. And the sticks in between them, this is a big question, forks or chopsticks. Raise your happened if you think it's forks. Raise your hand if you think it's chopsticks.
   >> All right I'm with the minority, I said it was forks, but the rule is for the dining philosophers, if the rule is they're sitting at the table and they have two forks available to them, they can pick it up and they can eat and they become an eating philosopher. If they only have one fork or no forks, then they have to be a thinking philosopher and they have to continue thinking until they have forks available to them so how do we model this in chemical processing, well, with molecules of course. So the F there is a fork. It's a fork molecule. And the TP stands for a thinking philosopher and the eat is an eating philosopher. So that's saying if a thinking philosopher has two forks. Likewise if an eating philosopher molecule runs into a think molecule it will turn into and react a thinking philosopher with two forks next to it so of course you want to see the demo.
   All right. So I can't do graphics very well so I did them all in a line but I'm sure it will be OK. So down here at the bottom, I'll point with my mouse, you have yellow is eating philosopher, and then you have TP is a thinking philosopher and then you have the forks in between them, and the molecules are moving up in a random order here. The think and the eat and they interact with each other. And they're just having a happy dining experience. Really.
   [laughter]
   And it makes a cool screen saver, too. But it's really fun that you could model such a problem with just simple reactions and thinking about things as molecules. It's really a cool way to think about things.
   So back to the presentation here. And with these simple behaviors, we can get some pretty interesting properties. We can combine these simple behaviors into self-organizing systems. We see this all the time in nature, as well, right? We see ants doing this with ant colonies, we piece doing this, as well, and see this all the time in mail systems. Well, we will. So we could model a mail system into how to be self-organizing by using a molecule system again. So mailboxes on the mail servers are going to be regarded as molecules. So you're going to have an in mailbox for A1 and on the other side you're going to have a in mailbox for B1.
   >> So it's going to want to get over to the in mailbox B1. And we're going to have another couple of molecules. These are server molecules. So we're going to have one for the A mail system and one for the B mail system and then we're going to introduce something new, they're going to be membranes. But the membranes aren't really special. They're just they're molecules again, but they're inert. They do not react with anything. And the purpose of the membranes is going to be to separate molecules in a solution. So it kind of controls what they can interact with.
   So to put this in motion, we have our mail message wanting to get over to B1 and it bumps into the membrane. So no reaction. Because membranes don't react with anything.
   So then it depose along, some random way, then it bumps into the mailbox A1. There's no reaction, because there's a rule there that says it only reacts if it has a matching address and it's not B1. So then it goes on its merry way and it reacts this time. It's a simple rule. A stuff stays on one side and if you're not that, you just get routed through the membrane partition over to the other side. So cool. It has another simple reaction. Very similar rules. If you're not on the A side you get routed across the way.
   >> And then it heads over to the server B. Again, it reacts. Shoves it over to the other side. And finally eventually it will bump into B1 and it matches address and we have the reaction, and the mail was received. So this is really cool. You know, very simple behaviors, and you can have a self-organizing mail system. But you can take it further. We can make this a self-organizing and self-healing mailbox or mail system, because these simple behaviors can combine to build resilient systems. So we can introduce another molecule called a crash molecule. And this bounces around and whenever it actually meets a server molecule, it will react with it and turn it into an unhappy inactive server molecule that will no longer react with things. Or react with the mail messages.
   >> But happily, we can have a sentinel fixed molecule that is patrolling the area and just randomly if it reacts with an inactive server molecule, it will turn it into a functioning server molecule again, and it can repair it.
   So wow! Let's see it in action!
   All right. I'm going to start this -- I want to make this big enough. OK, here we go.
   OK, so there's a couple crashes. There's some B messages over here. Oh, sorry, yeah, there's B messages over here that want to get over here, and they're being routed through. The A messages are trying to go over this way. Oh, so these two are down. Eventually when this fixed molecule gets over there, it will fix something, yay, it repaired it. There's one more crash over here waiting for it to happen. We did actually receive some mail, we got two mail messages in A2 already, we got one in A1, oop, a couple more went into B1, so stuff is happening.
   >>
   AUDIENCE MEMBER:  Like with spam.
   >> Right, spam. But yeah, so this is -- this is a really cool way to think of things. And again, it's all just combining these very simple reactions that don't have any order to them that are actually self-organizing and doing a interesting, I think, behavior.
   >> And I was late for dinner a couple times, just watching this. I was like, oh, I got to wait until the mail messages get in, but yeah, it's all just pretty cool.
   >> All right, I'll stop watching it. I can be mesmerized.
   OK, so what did we learn about this? Or what did I learn about this in my kind of explorations of the papers and this space? Well, there's a few things. Right? I mean the chemical programming is all about reactions. And it's really kind of a nice way to get to the heart of the things, get to the heart of the logic that you're trying to do with these things that are reacting. It kind of makes it very simple. It makes them simple and elegant, so I think that's got value in itself. The -- I think the most important take away that I got from it, is that it really eliminates this incidental sequentiality that we do every day. I mean most of our programming languages, we have lists of things and we traverse the lists and we traverse lists in an order and we loop over things, and I think we're so used to it that we forget about it. It just becomes invisible to us and it's nice to step back and think, do we even need that? Do we even need that sequencing to do our job every day? Is there another way to think about it and take that out of the picture? And I think this can be important, because so when you take the sequentiality out.  and also that the simple behaviors that they can combine, and you can really make robust systems with this. We saw this this in a example with the mailbox that again, they were just molecules, they were moving around, but eventually they got to the right place that they were supposed to go, they self-organized the system and you can make them robust by having other molecules that are standing around, ready to fix things if things go wrong, they don't to have knowledge about anything else going on, and they're just going on with their simple behavior and of course we didn't make this up. This is all taken from nature and this is what nature is doing within us and around us all the time. And I think there's lot of lessons that we can learn from nature and take and bring over to the systems and the tools that we build them with it.
   So thank you all. If you're interested. I have all the code for these examples out on my GitHub along with the demos. So feel free to, you know, explore and use the ideas. So that's it.
   >>
   [applause]
   So I think I have a few minutes for questions if there are any questions. I'll try my best to repeat the question. So if I don't, ask me to.
   >>
   AUDIENCE MEMBER:  I was curious if you experimented with sort of crowding behavior, you know, because the path that those molecules take through the system it incurs huge latency. So I was curious if you experimented with different ways of making the molecules go through different.
   >> So the question is did I experiment with any routing behavior with the molecules and the answer is no, but that would be really cool. That would be a great area to take in, and explore and it might are some real practical purposes, so yes, I encourage you to take it in that direction and do that.
   >> (Question from audience member:)
   >>
   >> OK, so the question and correct me if I have restated it wrong, in the demos, there was a similarity between architecture, enterprise patterns and what was the --
   >> ... The whole idea of messaging and pipeline and what happens with rules. It seems like you're essentially modeling the same thing, but different names around it.
   >> Yeah, yeah, so it looks very similar to pipelines and did you have that you'd see in enterprise integration and is this a different way of maybe modeling it? And the answer is yes, it is a different way of modeling it and I'm not really familiar exactly with the things that you're talking about so maybe you can talk more in depth with me afterwards, but I think there's value in trying to think of the world differently and see what falls out of it. So yeah, that's a good purpose. Oh, sorry back there?
   >>
   >> One cool thing about chemical reactions is that the reactions get used up. Do you know whether anybody's tried using that up in the type system, maybe with linear type theory.
   >> Oh, wow, so to restate your question, the cool thing about chemical reactions is they get used up, and how does that work with type theory, have you thought about it with that and no, but that sounds really, really cool, so, yeah, that could be -- -- yeah, do it. so, see, any more?
   >> I'm sorry?
   AUDIENCE MEMBER:  So I loved your talk, it really made me think and I love the demo and I think we may have the same religion. This idea of what ideas can we discuss and like Brownian motion -- I got confused about the dining philosopher's problem. Because the dining philosophers was set up. -- if you ever got into dead lock. The I guess the second question is can you implement a solution to the dining philosophers in this chemical paradigm or does that require too much sequentiality?
   >> OK, so to restate that briefly, he was thinking about the dining philosophers problem about having deadlocks and were there any deadlocks, so the answer was, no, there were not any deadlocks and also using core.async made that, you know, it didn't run into any deadlocks. And the second is using --
   You said you haven't seen a starving philosopher, but presumably you could and my question was, could you prevent that?
   >> Ah, could you prevent a starving philosopher with chemical programming? I don't know. But that's an interesting thing to think about and I would definitely would like to talk about that afterwards with you. How am I doing on time? You should wrap up.
   >> Oh, I should wrap up. Thank you all very much again, this has been a great exploration area with me, I'd be happy to talk about it. Thank you.
   [applause]
   [break]
