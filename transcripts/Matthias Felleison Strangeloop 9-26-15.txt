   Matthias Felleison: "Big-Bang: The World, the Universe and the Network in the Programming Language"
   
   [Live captioning by Norma Miller @whitecoatcapxg]
    ... ... ... ... ... ... ... ... ... good afternoon, everybody! . This a time to wake up again.
   >> And I really want to thank Michael and David for being the warmup band here. This is the main act.
   [laughter]
   >>
   [applause]
   >> Before I start, I would like you to hit GitHub like this. If you're here, you read the abstract, you downloaded it, you're ready to win a prize. Realm of racket, signed by one of the authors, there are 1 more to collect after that. And the way to get that is to install a little package in your -- you do that by going to the file menu, you say install package and you type S as in Strangeloop L as in loop, 2014. The 4 so that you listened, it's not 5. It's 4. Everybody listening and hit install and you're ready to go, OK? So Mike and David said big bang in 19 po. It was actually 1927 or 7 when Godel was visiting Princeton. It took 13 years to publish. This day we take 13 minutes to publish an idea that we have in the future, right? Something like that. So I want you to imagine the worst. Think ahead, think a bit more ahead. Imagine your children in middle school. It's one of the worst thoughts you can have. I'm through that. Some of you are up for that, right? OK. So that just about figured out 1 plus 1 equals 2 and now they're hitting them with questions like. Or they're telling them a horse buggy is leaving St. Louis now at 5 miles an hour, going to Chicago, when is it going to get there or how far is it going to be from here until X hours from now, right?
   >> And that's how we drone on our children have been doing it for 100 years, maybe 150 years in the American schools everywhere in the world and all we get out of that is boredom. Why don't we use pictures and animations? That's the starting point for big bang. It was 1995. When I collected my research group and we said we can do better. We should be able to turn this math into something that works on computers. OK, well, so to start with, you have an arithmetic of images instead of an arithmetic of numbers. Why don't we add a green circle and a brown rectangle, different kind of add than 1 plus 1. What do you get? You get a little tree. Well, suppose you have X is a horse buggy and why is the white background with a tree on it? What happens if you put the horse buggy at 0100? Well, you guessed it, you get the horse buggy on the white background. What if we change this word problem a little bit about the horse buggy going from St. Louis to Chicago and say, don't bother with computing this stuff, but draw the picture? Right? Draw a table of where is it at 10, where is it at 50, with is it at 120? Why why would we do that? Because if you put all these together we could come up with this kind of expression. Called a variable expression in middle school. That's what they're really asking for. Given T, place the horse buggy at five times X, five miles an hour, remember in this white background, which represents the distance between St. Louis and Chicago. And what you get is a whole bunch of pictures. And you guessed it, if you play this very quickly, you've got an animation.
   Right? So you can easily turn those problem sets into something we in this audience can turn this problem sets in middle school into something that goes for an animation as opposed to boring little calculations with numbers. So back to 1 995, what did we really try to accomplish? The idea was to combin mathematical subjects like math or in high school maybe physics, with programming, and so that the programming would help the mathematical disciplines and mathematical disciplines would help the programming. There's a back and forth. There's a synthesis between the two of them. What I don't care about is programming per se. I want to repeat that. I don't care about programming per se. I think it is a mistake of all of us to think that we need to teach programming. We should teach something so that kids who walk away from there, from this middle school never program again, but become doctors and journalists and artists, take something out of that thing, that synthesis of math and programming. And if you don't know what I'm talking about, here's the bottom line: I mean bottom line as in money. There's a study a longitudinal study by the USDOED Department of Education that if all under circumstances equal, your income will be higher at 30, right? Your understanding of the kind of function of middle school predicts your income at 30. The bottom line, I said so, right?
   So my dream was, and what we've accomplished with this big research team that we have here is a very smooth curve. What could the curve mean? The curve means you start at middle school with a curriculum that synthesized this mathy programy kind of stuff, you move on gradually, very gradually into high school, with a program called teach scheme. You move up to the first year in college. There's a curriculum called how to design programs and you can take this all the way to a junior level course in software development and in this day and age we actually conduct research on this stuff. We have pushed this to the point where we write with middle school software, we write DNS proxy servers. OK? That's possible. So that is approximately what I'm going to show you what I'm going to show you precisely is how to program in that world. Here is what I don't have time for today. I don't have time to show you how to teach that stuff. I don't have time to show you that with all this work comes the discipline of explicit systematic program design. I don't have time to explain to you how explicit systematic program design helps problem solving in the area of a surgeon, a journalist, an artist, a poet. OK?
   I don't have time to explain the teaching languages to you. I'm just show you the stuff. I don't have time to show you the IDE that we made, so simple, that middle school kids can use them, OK? So that's what I'm not talking about. So we're just going to the programming. So I'm going to start with a little demo. Gives you an idea how 1 and 1 is added in our world. Is that font big enough up in the top? Thank you. So 1 + 1, if if you add it just like middle school. How do you get pictures? Circle, 60, solid green. All right? rectangles and make it 10, say, and 50, and make it a brown one and if we put this above each other, so made a green tree, ecofriendly, right? Of course you can do other things, you can actually insert a picture directly into -- oops I'm going to do this differently. You can directly insert images into the IDE, because images are values. That's not not modern, that's 1995, right? You have a horse cart, a horse buggy right in the thing and as you already see, you can name values. Naming it is just like what they call a variable expression when they say if X is 5, well, we can say, if top stands for circle 70 solid green and stem stands for that and tree stands for that and we get exactly what we would like. We can for example see tree or we can see cart or we can give you -- oops. A scene with a tree or a scene with a cart. You can also write functions in this world. This function down here says, give me a time, T, I will place the cart at 5XT and 5 a 5 to the ride in top that's a scene place. Now, kids instead of using a calculator to calculate with numbers, they can say things like render at 102 and you get the tree or render at 55 and you get another scene or you can say animate this function. What does animate do? It plays it very quickly. What do you think is going to happen. This is a pop quiz what's going to happen when I hit return?
   >> The cart's dona move.
   >> The cart's gonna move, right? And we did nothing else. We literally moved, we did nothing else. In these calculations but high school prealgebra. Middle school prealgebra, that's exactly the material, 8th grade and that's what we teach, and other things, actually games, too, and we'll see in a moment in this world of mathematics.
   >> Let me go back to my talk. So how do you explain this thing when you get to high school?
   >> What we invented, what we really invented is what I call a functional system of I O. No more in outs required, OK? Big bang is a new language construct in which you describe worlds. So this is how you write it down. Just kidding. This is what it feels like. Big bang, we tell the kids in a programming course, is the representation of a little operating system. What do little operating systems do for you? They deal with events that happen. For example, they deal with a clock over there, or a game pad over there or a mouse up there, and I even had in a brain wave reader but when I demoed it, I couldn't get any activity, so I didn't do that.
   What I skipped was this little green circle there. This is -- it's a value that we give to mini OS to safeguard. One value at the beginning. Safeguard that thing. OK? So what happens when the clock ticks? OK, when the clock ticks, big bang hands over that little green value to the clock tick handler, a function that takes these kind of values and it can do anything it wants and compute with its value and when it's done, that handler hands it back to big bang. And now you're kind of done, except that there's this purple thing on the left. Your left, right, that thing.
   >> And I haven't talked about it yet. Well, every time one of these event handlers deals with an event, you get to get that green thing move into this renderer and externalizer. It also does whatever it wants with that green value. And out pops a picture, for example. We could externalize it in different ways, like sounds, taste. This is what it looks like in text. That value that you hand over is right there. We call this the state. But it's just a value. It could be 5. It could be the color green. It could be an image. Could be any value in the world that you can think of, you can put there. And then you have ha bunch of clauses where you describe the world that you wish to create. We call these things worlds. Let's create a world. You can put in a lot of clauses. The only one that's really required is the purple one that says to draw. And what these signatures tell you is that these handlers and renders take a state, something of typed state, and give you something back, no effects, none.
   >> OK? So to draw is a function that will take a function that takes a state to an image, a tick handler takes one state and gives a state back.
   For example you might want to simulate a clock. You do 5, one time tick goes away, you get 6 back. On key, you also have information about the keys.
   On a mouse click, you want to see where the mouse event happened and describe the mouse event and you can imagine many, many more handlers, the yellow one is another optional idea is, you can say let's close the world down when certain conditions hold.
   OK? So this is the idea. Let's demo that. I wanted to explain animate. What does animate do? Animate says, start counting at some time. I parameterized the function waddle, which simulates this little trip to St. Louis from Chicago and I say every time the clock ticks adds one to the number I give myself here. So for example X0 is 5, the clock ticks at 1, puts the 6 out, brings it back, big bang now controls the 6. Before there's anything else it hands over that number to the function renderer. And then you can run this thing just like animate. So that's waddle from St. Louis to Chicago starting at 10.
   And you saw the horse buggy at 10, comes over, now we've explained animate. This explanation is of course exists because we want to show students more than little animations. We want to show how to, for example, edit little text boxes, why don't we create a text box. Little show you first a little bit about strings. Hello Strangeloop, right? That's called a string. You've seen that kind of thing. I can make a big text out of that like a 222 purple-sized text. That's an image. OK? I can of course string a append. In our world we're very specific about what kind of things we add.
   And now we say no way hello Strangeloop. Now, I can explain to you what these little functions do. Here you see another big bang function. It takes an S0, which we now say is a string. And so the state that it keeps track of is always a string. When you press a key, I will append that key to the end. All I have to do now is after display every time the clock ticks, I have to display that hidden string from big bang onto the screen and it uses nothing else that we've seen before, plays an image here and there. You can run that. And you can edit. Well, maybe you can edit. Well, nothing happened. What's going on here? Oh, you can type. That's good news. Let's shift up. That doesn't go well, right? What's going on here? Let's start with nothing. I want to say hello, capital letters of course, hello Strangeloop and I get two shifts. What's going on? It's a aud editor, it just appends key strokes, I have to give you another thing, another idea that you'd get at that level in school. In 9th grade, and that's our first big success in 1995, fall of 1995, is conditional functions. We used that program, something like that, in a school for football players. This is Texas, right, so they have to repeat algebra from in the 11th grade from 7th grade and they didn't know what a sign function could do and our first teacher thought it's a conditional function, what could that be? It's that kind of thing. Now, imagine if you can demonstrate that thing with an actual conditional in the real world. What we do now is we are going to replace string append, plain string append with a new function called shift. OK. And that shift OK function down here is a conditional function. This one has only two classes. The key is recognized as shift, don't do anything. Just let the next letter go through. OK? Then you see stripping append as before, so you get the text, big bang hands over the text, it hands over the keystroke information, which is just a string, one letter, and you append that.
   >> Shift hello world. Well, I still can't delete things yet. That's not good. We should be able to delete things too, right? And you can delete things by putting in a function edit. Edit is a three-branch conditional function. You still see the shift key part but you now see the rubout key, rubout keys say take the last bit away. The last delete also of course is also conditional because if there is nothing in the string you don't want to delete anything, right? You can run that. Text box hello, and delete it. We have a ten-line program and kids can now understand how a text box works. It's very different of course, you could just give them a text box in editor but that's no good, really they won't understand. So I have added one more thing. Namely a mouse event. One line addition, what do you think that does? Pop quiz. I give you the current text, you give you where the mouse event happened, the X and Y coordinate, I give you a description of the mouse event, what are you gonna see if I move the mouse over my text editor?
   >> A blank. Let's try that out. This is important for your prize if you want to win your prize, right? And there we go, it goes away. OK? So these things you can very easily, big bang distills everything down to its essentials, it's completely functional, integrates its mathematics and gives you complete explanations of what things are.
   >> The universe, from big bang, you go to worlds, from worlds you go to universes. When each kid has a world running on his or her computer, they abort still, because kids want snap chat, or at least text to each other. Why don't we explain texting to each other in the same way?
   >> So in addition to functional I/O, no monads no shmonads, I will give you a way of communicating between worlds, having an actual universe with worlds floating around everywhere.
   So I didn't tell you the whole truth because big bang can really be introduced in little slices. Step by step. There's more to big bang than I told you. The yellow stuff is the new part of big bang. Take the example on tick. You now see a signature that says state to state and possibly a message. Where does this message go? Well, you see a whole new clause at the bottom called register. I can give this world a description of another world in the form of an IP address, and then every message that comes out of one of those handlers, if there is one, goes to that place, so somewhere out there on that machine there is another OS that these kids write, that takes care of these messages and for example it redistributes these messages so messages can also come into a world which is why we have one more line on receive, you get the current state, you get the message that's arrived and you do whatever you want, you give back a state or maybe a state and a message.
   So what sits in the center of the universe?
   Of course a server. And a server is exactly a just a specialized big bang world that takes care of messages. And it does so with a little value that it keeps track of. We can put anything this there, usually it's a list of representations of all of the worlds that float around in my universe.
   There are handlers, for example I can get a new world may show up and say I want to register with you. And then we do something with the current state, a representation of that world, and we come back with a bundle. On messages of course a handler takes care of when a message arrives in the central place, it takes the world that sent out this message, the message and also returns a bundle.
   So what's a bundle?
   Bundle is a bit of a mouthful, and we certainly should be a little better someday, but it combines the state that we want next with a list of mail messages and the rest is irrelevant for our little presentation here. What's a mail message? A mail message is a place where the message is supposed to go, a world, combined with a message. All right?
   >> It's time to demo again.
   I added two lines to the previous program. Two lines. The first one says, so second one says, when I want to register with local host. That's of course me. So they have a constant sitting there so I can run this little distributed programs and test them on their own local computer. And they have one handler on receive that says lambda and you all know lambda by now. Old state and a message and what I return is just the message. So clearly the arrival of a message wipes out what you had typed in to your text box there. Otherwise, text box stays the same. So we still have about 15 lines of code in here. Let me show you the central thing. This is the entire echo server, it will just broadcast any message that a high school student sends in to all the other guys that are out there. And how does it do that?
   You see, echo is a function, ignore the argument, it has an empty listing in there, there's nothing happening yet. That's the secret value for the mini OS and then say when a new world shows up. On new, we add this world, it's a function it's down here and when a message comes in, we broadcast this message. So how are these functions working out, right? Add-world takes the current state of the universe and all we do is we add the new world to the list of worlds. Otherwise, we do nothing. And that's the bundle we give back to universe, the server. Broadcast, it takes the state of the universe, the sender, and the message. Okay, and then it makes a bundle, it keeps the state around, because there's no new world, we don't want to throw a world out. We might, you could do something different, but otherwise, they say map, over this universe and create a mail that goes to each of those worlds with the current message. That's a little map thingy, you've seen that in your favorite language. Nothing else happens. How do you do that?
   So this module also loads the text box and I can now launch these worlds. I'm doing three worlds. One will show A. Another one will show B. A third one will show C. And then I can edit and hopefully things show up everywhere else.
   You see the A world, you see the B -- oops, the B world and the C world and over here there's a little window that tells me what message is going back and forth, the students can see what's actually happening and now I go over here. And I can type in 1, 2, 3. I go to the other world, I don't like 1, 2, 3, I say hello and I say hello and the last one can say something, too, and say goodbye and I kill this off and you see that the console tells me the universe is going down and we're ready. We are ready for a little competition, the box office opens up and I would like you if you would like to participate, to launch your Dr. Racket. Nobody? Open up your laptops. One person. Come on, open up your laptops, install the package. This is a live demo. Nobody else had the guts here to give you a live demo as far as I know. I'm going to fail. But at least I tried, right?
   >> What you will do in your Dr. Racket window, you will type in this. Require SL2014. Remember the 4 is to test whether you're listening. Then you say speak, hello Strangeloop or anything else that's long enough, 10 characters. I'm insisting that you count to 10. And then you give an IP address, the IP address is Antarcticca.CCS.NEU.EDU and it's in quoted string, OK? And you run that, oh.
   >> You've deposit a stray write at the end.
   >> I got a stray what? Thank you.
   OK. So I'm going to register myself, you see this appeared because the mouse is there, so you have to type something. I've got to tell you now what you have to type. Take your nametag. On the bottom right there's a 4 digit number. Type in that number. The fourth caller will get a signed book that says to the proud winner of Strangeloop 2015. Ready. Go. You have to hit return. That's the only change I made to the program. I'm going to try it, too. If you see thanks you're done. You can no longer do anything. OK. Anybody trying?
   >> I don't hear any responses. Yes.
   >> Louder.
   >>
   AUDIENCE MEMBER:  Woo!
   >> OK, that's all? You don't make much noise. OK, I said the fourth caller and the fourth caller has the number where is it? 4. 0668.
   AUDIENCE MEMBER:  That's me.
   >> All right, come on up!
   [applause]
   All right, that's it for demos.
   >> So what I showed you now up to this point is approximately what I have been working through from 6, 7th grade and we actually use a specialized big bang there. It's called game pad. The kids have a narrative worksheets and after about 8 weeks or so they have a full fledged game, little video game, people jumping all over the place stuff like that, you know, 1980s style. In high school we have had a couple of courageous teachers who actually did use the college course about you in the freshman course that I taught last time we did this. And what we did from there, a couple of years ago, we started with this idea of we could actually push this further. Remember this picture? Has all these worlds out there and then there's a network that connects this special room? We see this pattern over and over, even in Erlang, our underground language that Mike and David presented before and skipped over other interesting languages.
   [laughter]
   >> Did you notice that? Come on. So the idea that we had was maybe we could actually scale this up. We could build real systems in completely functional manner and what we -- the key idea was to fold that blue thing, to make this blue thing an actual part of the programming language. OK? And then you have the worlds sitting inside this -- or on top of this blue thing, and they can talk to this blue thing. The way the talk is kind of like what Peter showed you in the first keynote. You hand out assertions. And you make assertions about assertions and assertions about assertions that make assertions about assertions. Do you get that three levels? OK. And you can go on. And what you get from that is subscribe in a very, very different way. You can also nest these things so if you think of these yellow guys as functional actors because they're launched when assertions about assertions are interesting to them, you can also have a network inside and nobody knows that this actor isn't just a plain actor. It's a network of actors again.
   Another idea you can do, you can nest it arbitrarily deep. Turtles all the way up, usually it's down, but you know, the slide goes up.
   Right? What am do you get from that? We get a whole bunch of things, but before I go there, I want to show you what you do with it. Hopefully. We have haven't done it yet but we are about to. You can for example replace one network and have actors in different languages sitting there. One actor could be in functional Python. Or sorry. A good language, Clojure or something like that, or another one could be Racket. We could even imagine some Haskell kind of thingy, right? Or another network could be replaced with a multi-core network and you run this on top of the LAN and then on top of a wide area network, and all of this can be done within the language and can slowly be cut down into pieces. What we have gotten so far and we've explored this quite a bit with an SSH server and DNS proxy server, chat server, these kind of things, what you get is a completely different world of coordinated, concurrent groups of functional actors. And from that, we get scope conversations, each of those groups can talk each language. Of course we have hierarchies of those conversations. One thing you get, you get resource allocation. When one of those actors joins, we allocate the resources. When one of those actors fails, we remove the resources. Each level can be tuned to the level in the protocol. If you have 10 levels in your protocol, 10 headers, you have 10 levels. Each talks the level corresponds to one header. Everything becomes the completely natural design. OK. And now I'm going to put words into the mouth of the man who's actually doing that. Where's Tony?
   Well he's here. And if you see him, you can ask him about all these things, because he's built all these things and he's here to talk about it with anybody what wants to talk about it, OK? So that's Tony garnock-Jones and he's somewhere in the audience and he's the lead part of the people who built the last few steps we saw.
   I want to leave you with a little take away that's not researchy that was just a bit of an illusion that you can do research, you can do work that is good in middle schools and you can push it all the way to research, isn't it amazing? But what I want to leave you with is this image. We are, this group, I'm not -- I'm just here as the guy who is the oldest in the group, I'm closest to death, that's why I'm allowed to talk here, OK? But it's a whole group of like 10, 20 people who work with this all the time, we're the first ones ever to have built a completely smooth curve of programming that starts with 10 little 6th graders and goes all the way to the junior course in college in a completely smooth manner. It's completely thought out. It comes with a whole bunch of baggage that is not just programming, about you how to design them systematically, how to make it sign explicit and how to make an idea that grows with you from a tender young age to the age when you're ready to join the workforce. That's what I have to say. Thank you very much for listening. This is the end.
   [applause]
