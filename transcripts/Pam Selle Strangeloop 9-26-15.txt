   Pam Selle: "Streams: The Data Structure We Need"
   
   [Live captioning by Norma Miller @whitecoatcapxg]
   
   
   >> Good morning, so I'm going to go ahead and get started. So this talk is Streams, The Data Structure We Need, or it can be shortened to OMG Streams. Feel free to use it as a hashtag. And I'm Pam Selle, you can find me on Twitter @pamasaur, and thewebivore.com.
   So the thesis of this talk is a talk at all levels so we'll go from the beginning to the end, so streams are the most awesome data structure that you don't know enough about. So first we'll talk about streams, kind of context what they are. Streams, why you should be super excited about them as a data structure and we'll talk about because JavaScript is my jam we'll talk about streams and how they're expressed in Javascript now and we'll also talk about some libraries and emerging standards, because it's JavaScript and so there's always something new so that's the agenda for the day. So streams, streams? Streams. So starting with some history, so when I started getting really interested in learning about streams as a data structure, I wanted to see where it came from. And it seems as far as I could tell, that streams first made their appearance as a data structure in Unix, and so if you don't think you know much about streams, there's a decent chance that you've used streams as a data structure, just in your terminal on the day to day. So all glory to the pipe operators. So the pipe operator is that skinny line in between these two commands. So cat being the command that contact nates to the terminal and grep being a local search and replace. So in this a text file that's best animals and we're going to search within it an instance of cats. So best animals by itself, and then let's search case insensitive for instances of cats, because the internet is run by cats and we see that we use the pipe operator to take the output from the first command and send it to the second and command, so that's what happened. And the red line is the pipe operator. So what are streams? That's a oh, you're probably using streams without even use realize it and that's where they come from historically but what are they? Streams are an abstract data structure, I sometimes have a hard time wrapping my head around them because they have that convenient word abstract in front of them. So what that means is we might not, in some cases we will, about you we will see streams expressed but they can be expressed in many different ways because they're abstract, so sometimes it might not even be called a stream and sometimes it will be called a stream and there will be many different implementations of it and you might have already been at talks about streams already here at Strangeloop, so streams are an abstract data structure and I'm going to do a real world demo to show you how streams work. So over here, I have some cups, so in -- I'm going to left to right, so my right, your left, so in the first cup I have water.
   And the ultimate goal is that it has to get to this cup. But because reasons or business logic, it has to go through this middle cup in between. It has to. It's the world. So we can do it this way. And we do this kind of operation all the time. We take a source, and we transform it somehow and we put it somewhere and then we ultimately output it. However, if you want to do it a different way, just shuffle these up, let's replace that middle cup with something a little different.
   So that's pretty much how streams work if you were to teach it elementary school science class in my humble opinion and it's a fun way of thinking about streams, so instead of pouring from one into the next and into the next and doing things sequentially in that way, we send it through to the output.
   So I'm going to reference SICP a couple of times in the talk and just in case you haven't heard of it structure interpretation of computer programs is generally a textbook. If you have a degree in computer science, you may have used it, if you have a degree in computer science and you haven't read it, you probably feel guilty about it and so what does SICP this canonical text say about streams? So SICP say streams are a delayed list. So what does that mean? So a delayed list means we can treat them mostly like a list structure but you don't have or you don't have to have all the values at once. So it's a data structure that lets us do list operations without the expense and announce of having to have them in a list structure, so that they become really powerful. So why would you use them? So they're really powerful but why? So because we can't or don't want to hold everything in memory, so we got to avoid holding things in the middle cup in our science experiment, and bandwidth is expensive. These are facts that are still true about the world. They haven't changed yet. But meanwhile, while bandwidth is still expensive and we don't want to store all the things in memory, streams are a really great data structure. So streams and why you should be super stoked about them. So streams let you represent possibly infinite data. Infinite data, making you essentially a wizard and the really, really cool and that's why I got really excited about them as a data structure and I wanted to write a talk about them.
   So what are some things that don't have -- you say infinite data, there's no such thing as infinite data. Wrong. We have natural numbers. There's no such thing as a terminal natural number. Because any time we have any number, we can always make a new natural number by adding 1 to it so there's no such thing as a final natural number. Weather, user input, key strokes, large datasets and your heartbeat, these are stars next to them because they definitely do have an end, but you just don't know what it is. So while you're collecting data, you operate on the assumption that you don't -- you don't know when it ends, and streams let you do that.
   So why I brought up SICP is I don't really like using quotes in talks but I real why I really liked this. So stream processing lets us model systems that state without ever using assignment or mutable data. That is really awesome. So let's do it again. So stream processing lets you have your state but you don't have to use assignment or mutable data. The things that we aren't that into.
   So you can move faster, you aren't storing things in memory and we aren't mutating data. Very popular topic at Strangeloop. So modes of stream. So that's streams the a the very abstract sense but then you kind of have two modes that you can express them in. You can express them in push and pull modes. So what's a push stream in so a push stream is like the firehose so it's like I think the fire hydrant is a pretty apt image to think of. It's just coming out, and so -- and especially in streams, you'll see the language expressed in multiple ways, so we have a producer, a consumer, we have a source, we have a observed and the observer and we're using different language bus we're talking about the same thing, they're all streams. But because they're an abstract data structure, I think that's why we end up using different language so you might be using a push stream if you see things like callbacks, so when I have stuff from the source, do something with it. They're nonblocking so the fire hydrant is just blasting stuff out at you or the firehose is open. And the why unside, because everything has a downside there's a downside to every implementation is possible overload so it's like if you opened a firehose on a tiny Basil plant, it wouldn't handle it very well, so thinking about the context will change what kind of stream implementation you would want to use.
   So a pull stream is the ideally the opposite in a way. So instead of the source or the producer pushing all that, see, push stream, pushing all that data at you, in the pull stream the consumer is in charge of getting their data. So if you have a tiny Basil plant it could wave its hand and say oh, I need more water, please, and so you night might be using a pull stream if you see things like iterators and they are blocking and so I love this from -- I think I first heard it from Jessica Cara's talks that you'll have to time out because if you are blocking, you need to never ever block forever. And so I think of this, I think of pull streams, like it's kind of like a lake and there's like a lake of data, and you have you a bucket. And you have a bucket, and you can walk the lake, and you can get your water, it's a lot of water themes here. And so you can walk back to your campsite or what have you, but while you're doing that, you can't do anything else. Like you're carrying the bucket and back and forth, and you can take the bucket and do your thing, but then you have to walk back, and that takes time, so it's blocking. So that's how pull streams, that's their tradeoff is that while you have more control over when you get your data, you end up blocking. So streams in JavaScript, so what do we have right now in JavaScript? So node streams are conveniently named, are push streams, so a node stream throws data at the nest which makes a lot of sense in the JavaScript context, too. So the classic example, so substack has all this great stuff about streams and node and so that's going to be in the reference sheet, but here is a simple example of a silly node server, so it does a thing, here's the important part. So the important part is that fs, file system, reads a file and it reads it all in memory and it sends the data to the response. So that's one way to write a server. You know, that's one way.
   Another way is to write a server with a readable stream and so here's the important part, the spacing is a little different, so that I could fit it in well. But so the stream, we create a readable stream, and then I love that this is why mentioned Unix, as well, earlier is that it uses the pipe keystroke so I feel like they fit the mental model what a stream data structure is really well to me. So we take the stream and we pipe it into the response just like we would in Unix, well, not just like, but eh, you get the idea. So we're piping rather than using memory and so when you see this action on the server, you can make the server a lot faster, you don't have to store things in that second vessel, second or N.th vessel. So go streams, they're awesome. I like them.
   So we have generators, and this is a very new thing to JavaScript land so it's available in other languages in different forms but in JavaScript this is how we have generators, so generators are reusable pausable functions. This is the thing, they're reusable and pausable functions, so that sounds familiar. Are they pull streams? So because you ask for more when you want more, and that's how a generator works, it's an iterator, it's blocking, it looks like all those things that we talk about when we talk about -- talk about pull streams.
   So when you use a generator if you want to move to the next value, you call next, you say I'm going to take the bucket again and go get more data. So you know it's a generator when, let's talk about how they look in JavaScript so in JavaScript we have the function and the star and the yield. And if you see these two bits you're working with a generator. So here's a simple example so a function something yields 2. OK, great, so it's reusable, so we can create an instance of it and so we say S equals a something, and then we say S dot next and that will get us back. We'll get our yield.
   So generators demos. So let's have some fun with grens. Here's a simple generator. Let's see if it works right away. So each time I click the button I'm going to iterate through the generator. So we'll look at it happening and then we'll look at the code that makes it happen. We're adding something, something else, something else entirely and if I keep playing the button it's still done. They're read once, like once you get all the water out of the lake there's no more water in the lake.
   So that's a simple generator, so let's see what it looks like over here. So here's some setup and just here at the top of the elements and clicking and so here's our -- remember we said, OK, we have our function star and we have our yield, so that means we're working with a generator and so when we go through it and we first call it, so next value is what we're doing each time we click so we create a paragraph element and I'm actually passings, I'm yielding this so that I can inspect the done value. So generator done is so generator.next.done and that's actually calling the generator there. So what's happening is each time we call it, so the first time we call it we're getting to this yield and so we yield this. That's the first time and so we saw a console log something. The next time we console log something else and we get to the yield. The third time we call it we have no more yields but we have still a final line in our generator, and so that's when it gets executed which is a really case use case for app cleanup or a finally that you might want to do at the end at the end of a consumption of some data. So now that we've looked at it let's run it again to try to embed that knowledge. There we go, we should have pushed that button down. Right? Something, something else, and something else entirely.
   And so that's the simple and less trivial example. Let's switch to a different one.
   So just change the JavaScript file. And then we'll have a different generator running when I should have pushed that button down. All right, here we go, generate, John went to the store and said hey there to the clerk.
   So that's our different generator, so what's actually happening? So this is still trivial but minorly less trivial example. So string breaker, because reasons, it breaks up a string and gives you back a word much ooh time, unless there is a phrase or statement in quotes. It's very simple, so the stream breaker has an accumulator, where you look at 4 of, which is actually also, a cool syntaxing that I'm really into. You were sad about 4 in. Now you have 4 of, be happy. So we have -- we have kind of a state machine of sorts running through and so we yield and then we return at the end, just to be good about it. And so here's the at the end, so each time we click we're appending a new word, so John went to the store and said "Hey there" so that's our in quotes to the clerk and with the for of, we could also do this, we could use for of with generators, so not only with object literals where everyone has done this, where we end up with indexes instead of variables, it's and terrible. Shhhh and we could iterate through the whole generator and just say I want everything from the generator and you can set up more complex generators from this and just say give me all of it, give me all of the data from the generator. So that's the basics of JavaScript generators, AKA pull streams? So can you use them? I'm actually doing these demos in Chrome with no polyfills, so yes, but everything in JavaScript you probably need a polyPhil if if you want to support other people. babel.js is what you would use.
   So we also have some libraries and emerging standards that are really exciting. So some libraries in, working with streams, so the three ones that I would say are will major ones that I like a lot, bacon, Highland and RX. Here's bacon.js with the scary parts taken out. If you didn't get that he can Jo I crossed out everything that said cross rec tive. It's very JQuery-Y, I believe it even uses the dollar sign so you get your list operations on stream-like objects such as event streams, so remember, user clicks, hovers, any kind of browser event is a series of values that we don't know when it ends, so it can be expressed as a stream.
   Highland.js I really like and this is kind of the first one that I got into, because I liked it as a stream constructer. So I like when the words actually map to the computational concepts and so the stream constructer accepts an array of values or a generator function as an optional argument. So it lets you put in a lot of different values.
   So you could use arrays, generators, Node readable streams. I actually like it for this reason, that it's providing a common interface for many different types. So I think that's really cool.
   And then RXJS reactive tools, stream-friendly, batteries included. There's a version being built right now I'll briefly mention later.
   So hold on reactive programming this is the Trojan horse in the JavaScript talk but we're at Strangeloop so you aren't actually surprised. It might have been my favorite talk at Strangeloop in 2014, Evan's talk on the formulation of FRP and I've watched this multiple times and in terms of being able to understand FRP or RP conceptually, I really think it's absolutely fantastic.
   Also recommended, Staltz has this intro to RX blog post that's actually a gist but it's really good. I think if you're following along with this, you're probably having that realization that in the world that we exist in now, I would say streams are like the data structure, like we exist in massive amounts of data, we exist in realtime data, so data when we don't know when it's going to end, and data structure for you, for you my friends, is streams.
   Emerging standards, so again it's JavaScript so of course someone's writing some specifications on this. So let's see what we maybe or may not get. So the thing that this is really cool, so there's actually a browser stream standard so that we can actually get a stream data type in the browser. This is a rough one, because it's going to involve browser vendors, it's not a standard library kind of thing. It's a browsers have to be able to support it. But if and when it happens, it's going to be really awesome, and among the many people, working on it, there are people from the Node team that are involved in this spec and of course you can always check the specs and they're being updated constantly.
   Fetch API, the stream spec is also that you should get really excited about this one. So the fetch API is going to prevent you from ever having to write X or data query ever again or pulling in JQuery so you don't have to. Makes it into a native API and of course there's polyfills for this and so you can use it now but the really cool thing about the fetch API is that not only is it providing that kind of dollar a day -- that's the first Node server we looked at. In the future when we have the browser streams it's going to look like that second Node server and this is really, really cool. So when we -- because how many times have you had to -- you get your data, and then you have to, you know, deal with it being JSON of course, so we get response at.JSON. When that at streams, you should, my dream is that you will be able to do things like massive data visualization, like that's the thing that I'm most excited about. And that's the beginning. That's just the most obvious things to me, which means that people are going to do really cool things with it, if massive data visualizations is the first thing I thought of. But being able to handle data without pagination, big deal. Being able to I'm just so excited about the data visualization opportunities in this. object.observe. ES7, AKA2016, not now, eventually, but object.observe so given an object or object things which in JavaScript is almost everything, we can observe it and then react to changes, so does that -- that sounds familiar, right? That sounds like a push stream, so it's a series of events and we react when it changes, we're consuming the data pass we get it. The observable type really cool one. And so this is what we see in the Rx js library, so this existing library that people have been using for a while, the main stuff of it is in observable type and that's actually proposed to be added to the standard library next year, so proposal for ES7, so we can create an observable of values or events, and then we can do list operations on them. Remember, list operations without the announce and expense of lists?
   So some small projects using some of these tools. So we talked about history, we talked about JavaScript today, we talked about emerging things and I've got some examples of me actually doing stuff with these so that you can actually see them in action. So the last week blog. So tell me what's new from the last week on my blogs, so in this somewhat trivial example. So watch this screen, ooh, am I on the WiFi? We'll see, otherwise everything else is already offline, but this one depends on hitting the network. Did you see that? Did you see it didn't -- it didn't render like a usual browser page, so what's actually happening in the last week blog is it's fetching all these, there's a YAML file in the project that has names and locations of different blogs, so that I could check and see, hey, like are there, you know, have my friends written anything in the last week? I put New York Times because sadly my friends aren't super prolific on their blogs, but you can see it actually went like this. You didn't kind of get a kind of standard browser flash and so that's actually what's happening in last week blog and it uses Highland to do this and of course the source is on my GitHub, it's very trivial but hopefully that makes it more accessible to see what's going on. So we go and get the source of the blogs, get the RSS, transform it, filter it, list operations and then we pipe that response to the browser as we get it, so he we don't have to wait for you know, because as cool as processing RSS feeds is, we don't have to store all that in memory, we just we deal with it and we're done with it and then we get our answer.
   So that is last week blog. So the space time app uses the fetch API. Sadly we don't have browser extremes but it does use the peach API. There's a Delaurian forward and backward, we've all seen the movies right? And it's really cool. I think it's correct plus or minus 100,000 years, but at that point relativity comes into play but it's pretty cool to think about how our stars didn't look the same, as you know, a thousand years ago, based on our place in space. Anyway, so this uses a lot of data, so what it actually looks like when it's using the fetch API is it fetches a stupid number of stars and returns and then does stuff with the stars, and then we, you know, do all this cool 3JS stuff to represent the in a visualization. Also bonus of course, if you're a JavaScripter, you might have heard of, you know, every single build system, but one of them is gulp and why gulp is a bill system, big fan is that it release on streams so we do things and we actually have a pipe operator, so -- I love when the language maps to the mental model. I feel like it makes it really sticky and so that's why, when you switch from another build systems, grunt, to gulp, you might see huge gains in speed. Because instead of storing things and then doing things with them, you're piping the values. You do sometimes get race conditions but that's going to happen and you can deal with it. I didn't deal with it very well here, but other people can.
   OK. Millennials to snake people. So this uses object.observe to observe mutations to the DOM and appropriately update uses of the word Millennial. So this was first Wayne by Eric Bailey for Chrome and I added the Firefox extension and so you get something like this. Which makes reading the news a lot better. This paragraph has probably my favorite. So replacing lots of vocabulary associated with Millennials with appropriate snake-related puns. So and the code using observe and you know, and it's so disturbingly simple, it's so great so walk the document and replace things, we even replace the title of the document. So watch mutations, so watch when things change, and hit our callback. Spoiler, that callback places mentions of the word Millennial or you know, my favorite is that Millennial children become snakelets. But all credit to Eric. It was a very fun and funny idea. And that's using streams, so we're using object.observe to replace things.
   I call it art. This is silly art with Rx JS, hello, click to move the circle. So let's open the console, as well and I'm moving the circle around and I'm getting my coordinates back, so I could do other interesting things, but my art is very simple, you know, I like it that way sometimes. But in Rx JS I just created an observable and we're watching clicks and we're reacting to them. I can do it fast, too.
   So some interesting links. Links that we have are Node streams, so conveniently there's a web side called node streams.com. Some generators, I really like, so Getify on the internet is Kyle's thing. We got to be more creative. Like, once we have a new field, we should try and do weird and interesting things. Or, you know, useful that's good, too. So the router is user, so the router is showing, that hey, don't we tend to make routers a lot? What if we made a reusable router and so that's a generator. And in his book, you don't know JS, there's the asynch and performance generators chapter I really like it and Rauschmeyer has generators posts all the time and she is slides are on the internet so you can go and get all the links separate from them.
   So those reactive programming libraries, bacon, Highland and RS.
   >> And other cool reactive things. Rx JS is cool, it's not super usable like when you're coming to it as a new person and it definite Ily has some it's become rewritten underneath an umbrella and all that is happening in the wild. The alpha is out. You can go and contribute to it. Especially would like to see more people contributing docs because I'm doing that a bit and fresh sets of eyes are many so of the most invaluable things on emerging projects before they get too far down a bad path and also created by Staltz are the Rx marbles which if er' newer to many so of those list operations, you're operating on those list functions on streams, the Rx marbles are really cool way to visualize it. And if you said to yourself, all those libraries sound great, Pam, but I really need a JavaScript framework, you can use cycle.js and so this is a framework that is based on Rx JS and uses reactive programming as a first classes and in the JavaScript framework, so it's pretty new, I'm interested in seeing where it's going but if you're interested in this you'll want to check it out. So the slides are this link, I'll tweet it out. And thank you very much. You can find me for questions, mingling around. I'll do that, also Twitter pamasaur, the webivore.com, so if you have questions, let me know, and thank you so much ... ... ...
   [break]
   
